# 8.17 (수)

>> 인프런 (자바 ORM 표준 JPA 프로그래밍 - 기본편) 

SEQUENCE 전략 - 매핑 

```java
@Entity
@SequenceGenerator(
	name = "MEMBER_SEQ_GENERATOR",
	sequenceName = "MEMBER_SEQ", // 매핑할 데이터베이스 시퀀스 이름 
	initialValue = 1, allocationSize = 1)
public class Member {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, 
				generator = "MEMBER_SEQ_GENERATOR")
	private Long id;
```

>> SEQUENCE - @SequenceGenerator 

- 주의 : allocationSize 기본값 = 50

속성 / 설명 / 기본값 

name / 식별자 생성기 이름 / 필수 

sequenceName / 데이터베이스에 등록되어 있는 시퀀스 이름 / hibernate_sequence

initialValue / DDL 생성 시에만 사용됨, 시퀀스 DDL을 생성할 때 처음 1 시작하는 수를 지정한다 / 1

allocationSize / 시퀀스 한 번 호출에 증가하는 수 (성능 최적화에 사용됨) 데이터베이스 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 이 값을 반드시 1로 설정해야 한다 / 0 

catalog, schema / 데이터베이스 catalog, schema 이름 

>> TABLE 전략 

- 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략
- 장점 : 모든 데이터베이스에 적용 가능
- 단점 : 성능

>> TABLE 전략 - 매핑 

```java
create table MY_SEQUENCES (
	sequence_name varchar(255) not null,
	next_val bigint, 
	primary key (sequence_name)
}

@Entity 
@TableGenerator(
	name = "MEMBER_SEQ_GENERATOR"
	table = "MY_SEQUENCES",
	pkColumnValue = "MEMBER_SEQ", allocationSize = 1)

public class Member {
	
	@Id
	@GeneratedValue(strategy = GenerationType.TABLE,
									generator = "MEMBER_SEQ_GENERATOR")
	private Long id;
} 
```

운영에서는 테이블 전략 쓰는 것이 부담스럽다 

>> @TableGenerator - 속성 

속성 / 설명 / 기본값 

initialValue / 초기 값, 마지막으로 생성된 값이 기준이다. / 0

allocationSize / 시퀀스 한 번 호출에 증가하는 수 (성능 최적화에 사용됨) / 50

>> 권장하는 식별자 전략 

- 기본 키 제약 조건 : null 아님, 유일, 변하면 안된다
- 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다. 대리키(대체키)를 사용하자
- 예를 들어 주민등록번호도 기본 키로 적절하지 않다
- 권장: Long형 + 대체키 + 키 생성전략 사용

자연키 : 비즈니스적으로 의미있는 키, 예를 들면 주민등록번호 

절대 비즈니스를 키로 끌고오는 것은 권장하지 않는다 

- [x]  어제 코드리뷰에서 받은 질문 찾아보기
- NameApplication & JpaMain 차이점
- Entity가 어떤 역할을 하는지
    
    객체와 테이블 매핑 
    
    테이블과의 매핑 
    
    @Entity가 붙은 클래스는 JPA가 관리하는 것으로, 엔티티라고 불림 
    
    속성 : JPA에서 사용할 엔티티 이름을 지정, 보통 기본값인 클래스 이름을 사용 
    
    주의사항 : 기본 생성자는 필수 (JPA가 엔티티 객체 생성 시 기본 생성자를 사용) 
    
    final 클래스, enum, interface, inner class에는 사용할 수 없음 
    
    저장할 필드에 final 사용 불가 
    
    [https://ttl-blog.tistory.com/112](https://ttl-blog.tistory.com/112) 
    
    쉽게 생각하면 DB 테이블에 대응하는 하나의 클래스 
    
    @Entity가 붙은 클래스는 JPA가 관리해주며, JPA를 사용해서 DB 테이블과 매핑할 클래스는 @Entity를 꼭 붙여야만 매핑이 가능하다. 
    
    주의사항 : 
    
    - 접근 제어자가 public 또는 protected인 기본 생성자가 필수 (구현체에 따라 다른 것도 있으나, 스펙상 사용하지 못하도록 해두었기 때문에 사용하지 않는 것이 좋다 )
    - final 클래스, enum, interface, inner 클래스에는 사용이 불가능
    - 저장하려는 속성은 final이면 안된다 (구현체에 따라 다른 것도 있으나, 스펙상 사용하지 못하도록 해두었기 때문에 사용하지 않는 것이 좋다 )
    
- Setter 지양
    
    [https://velog.io/@hope1213/Setter-사용을-왜-지양해야할까](https://velog.io/@hope1213/Setter-%EC%82%AC%EC%9A%A9%EC%9D%84-%EC%99%9C-%EC%A7%80%EC%96%91%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C) 
    
    사용하면 안 되는 이유 
    
    - Setter method를 사용하면 값을 변경한 의도를 파악하기 힘들다
    - 객체의 일관성을 유지하기 어렵다
    
    Setter 대신 다른 것을 사용하자 
    
    - 생성자를 오버로딩
    - Builder 패턴 사용
    - 정적 팩토리 메소드
    
- Transaction의 all-or-nothing 방식 위주로 공부
    
    Transaction의 4가지 속성 만족 
    
    1. 원자성 : transaction은 연산들을 전부 실행하든지 전혀 실행하지 않아야 일부만 실행해서는 안된다. All or Nothing
    2. 일관성 : 트랜잭션이 성공적으로 실행되면 데이터베이스 상태는 모순되지 않고 일관된 상태가 된다. / 출금한 금액만큼 입금이 이루어져서 출금 데이터와 입금 데이터가 일치해야 한다 
    3. 격리성 : 트랜잭션 실행 도중의 연산 결과는 다른 트랜잭션에서 접근할 수 없다 / 출금을 하는 중에는 다른 사람이 출금을 실행할 수 없다 
    4. 영속성 : 트랜잭션이 성공적으로 완료되면 그 결과는 영속적이다 / 데이터가 어딘가 저장되어 있어야 한다 
    
- 내장 WAS 에 대해 자세히
    
    [https://kkambi.tistory.com/99](https://kkambi.tistory.com/99) 
    

>> 실전 예제 - 1. 요구사항 분석과 기본 매핑 

>> 요구사항 분석 

- 회원은 상품을 주문할 수 있다
- 주문 시 여러 종류의 상품을 선택할 수 있다

>> 기능목록 

>> 도메인 모델 분석 

- 회원과 주문의 관계: 회원은 여러 번 주문할 수 있다 (일대다)
- 주문과 상품의 관계: 주문할 때 여러 상품을 선택할 수 있다. 반대로 같은 상품도 여러 번 주문될 수 있다. 주문상품이라는 모델을 만들어서 다대다 관계를 일대다, 다대일 관계로 풀어냄

 >> 테이블 설계 

>> 엔티티 설계와 매핑 

- [ ]  intellij 에서 h2 연결하기

[https://w36495.tistory.com/28](https://w36495.tistory.com/28) 

→ IntelliJ에 h2 연결하기 

[https://pakker.tistory.com/105](https://pakker.tistory.com/105) 

→ h2 사용 방법 및 intellij 연동 방법 

[https://blog.advenoh.pe.kr/spring/H2-데이터베이스-사용법-및-Intellij에서-Database-연동/](https://blog.advenoh.pe.kr/spring/H2-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%82%AC%EC%9A%A9%EB%B2%95-%EB%B0%8F-Intellij%EC%97%90%EC%84%9C-Database-%EC%97%B0%EB%8F%99/) 

→ H2 데이터베이스 사용법 및 Intellij에서 Database 연동하기 

- [ ]  코드 작성해야함

>> 데이터 중심 설계의 문제점 

- 현재 방식은 객체 설계를 테이블 설계에 맞춘 방식
- 테이블의 외래키를 객체에 그대로 가져옴
- 객체 그래프 탐색이 불가능
- 참조가 없으므로 UML도 불가능

- 연관관계 매핑 기초
- 단방향 연관관계

연관관계 매핑 기초 

>> 목표 

- 객체와 테이블 연관관계의 차이를 이해
- 객체의 참조와 테이블의 외래 키를 매핑 (이걸 배운다)
- 용어 이해
- 방향 (Direction) : 단방향, 양방향
- 다중성 (Multiplicity) : 다대일(N:1), 일대다 (1:N), 일대일 (1:1), 다대다(N:M) 이해
- 연관관계의 주인 (Owner) : 객체 양방향 연관관계는 관리 주인이 필요

→ JPA 계의 포인터 ㅋㅋ (JPA에서도 이게 제일 어렵다) 

객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다 

→ 조영호 (객체지향의 사실과 오해) 

>> 책 추천 

- 객체지향의 사실과 오해 (조영호)
- 오브젝트 (조영호)

>> 예제 시나리오 

- 회원과 팀이 있다
- 회원은 하나의 팀에만 소속될 수 있다
- 회원과 팀은 다대일 관계다

>> 객체를 테이블에 맞추어 모델링 (연관관계가 없는 객체) 

[객체 연관관계]

[테이블 연관관계] 

- [x]  관계형 DB 공부

[https://www.oracle.com/kr/database/what-is-a-relational-database/](https://www.oracle.com/kr/database/what-is-a-relational-database/) 

>> 객체를 테이블에 맞추어 모델링 (아래 키 식별자를 직접 다룸) 

```java
// 팀 저장 
Team team = new Team();
Team.setName("TeamA");
em.persist(team);

// 회원 저장 
Member member = new Member();
member.setName("member1");
member.setTeamId(team.getId());
em.persist(member); 
```

문제 : 

- [ ]  maven 파일 생성 시 java source 코드가 안 나오고
- [ ]  intellij에서 maven 파일 만들면 자꾸 오류남
- [ ]  h2 db 연결

>> 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다 

- 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾는다
- 객체는 참조를 사용해서 연관된 객체를 찾는다
- 테이블과 객체 사이에는 이런 큰 가격이 있다

>> 단방향 연관관계 

>> 객체 지향 모델링 (객체 연관관계 사용) 

아니면 intellij로 maven 생성 한 다음에 내가 따로 만들어도 되나?

>> 양방향 연관관계와 연관관계의 주인 1 - 기본 

JPA계의 포인터

한 번 잘 들으면 어렵지 않다 

>> 양방향 매핑 

- 양방향 객체 연관관계
- 테이블 연관관계

- [ ]  인프런 강의 질문 게시판에서 maven 파일 생성 찾아보기

>> 연관관계의 주인과 mappedBy

- mappedBy = JPA의 멘탈붕괴 난이도
- mappedBy는 처음에는 이해하기 어렵다
- 객체와 테이블 간에 연관관계를 맺는 차이를 이해해야 한다

>> 객체와 테이블이 관계를 맺는 차이 

- 객체 연관관계 = 2개
- 회원 → 팀 연관관계 1개 (단방향)
- 팀 → 회원 연관관계 1개 (단방향)
- 테이블 연관관계 = 1개
- 회원 ↔ 팀의 연관관계 1개 (양방향)

>> 테이블의 양방향 연관관계 

- 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리
- MEMBER.TEAM_ID 외래 키 하나로 양방향 연관관계 가짐 (양쪽으로 조인할 수 있다)

```sql
select * 
from member m 
join team t on m.team_id = t.team_id 

select * 
from team t 
join member m on t.team_id = m.team_id 
```

>> 둘 중 하나로 외래 키를 관리해야 한다 

>> 연관관계의 주인 (Owner)

양방향 매핑 규칙 

- 객체의 두 관계 중 하나를 연관관계의 주인으로 지정
- 연관관계의 주인만이 외래 키를 관리 (등록, 수정)
- 주인이 아닌쪽은 읽기만 가능
- 주인은 mappedBy 속성 사용 X
- 주인이 아니면 mappedBy 속성으로 주인 지정

>> 누구를 주인으로?

- 외래 키가 있는 곳을 주인으로 정해라
- 여기서는 [Member.team](http://Member.team) 이 연관관계의 주인

진짜 매핑 - 연관관계의 주인 (Member.team)

가짜 매핑 - 주인의 반대편 (Team.members) 

[연관관계 매핑] 

DB 테이블에서 N쪽인 곳이 연관관계 주인공이 되면 된다 

비즈니스 적으로 중요하지 않다 

>> 양방향 연관관계와 연관관계의 주인 2 - 주의점, 정리 

양방향 매핑 시 가장 많이 하는 실수 (연관관계의 주인에 값을 입력하지 않음) 

```java
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setName("member1");

// 역방향 (주인이 아닌 방향)만 연관관계 설정 
team.getMembers().add(member);

em.persist(member); 
```

양방향 매핑을 할 때 양쪽에 값을 넣어주는 게 맞다 

>> 양방향 연관관계 주의 - 실습 

- 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자
- 연관관계 편의 메소드를 생성하자
- 양방향 매핑시에 무한 루프를 조심하자
- 예: toString(), lombok, JSON 생성 라이브러리

중요한 건!!

코드를 작성하고 실행하고 에러메세지 보는 것 

controller는 entity 반환하지 마세요. 

- 무한루프 가능성

entity는 DTO로 변환해서 반환해라 

>> 양방향 매핑 정리 

- 단방향 매핑만으로도 이미 연관관계 매핑은 완료
- 양방향 매핑은 반대 방향으로 조회 (객체 그래프 탐색) 기능이 추가된 것 뿐
- JPQL에서 역방향으로 탐색할 일이 많음
- 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨 (테이블에 영향을 주지 않음)

처음에는 무조건 단방향 매핑으로 매핑 끝내야 함 

객체 입장에서 양방향 한다고 크게 좋은 점 없음 

기본적으로 단방향 매핑으로 다 끝낸다고 생각하기 

>> 연관관계의 주인을 정하는 기준 

- 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨
- 연관관계의 주인은 외래 키의 위치를 기준으로 정해야 함
- 외래 키가 있으면 연관관계의 주인이다

>> 실전 예제 - 2. 연관관계 매핑 시작 

테이블 구조

- 테이블 구조는 이전과 같다

객체 구조 

- 참조를 사용하도록 변경

>> 다양한 연관관계 매핑 

>> 다대일 

>> 연관관계 매핑 시 고려사항 3가지 

- 다중성
- 단방향, 양방향
- 연관관계의 주인

>> 다중성 

- 다대일 : @ManyToOne
- 일대다 : @OneToMany
- 일대일 : @OneToOne
- 다대다 : @ManyToMany

서로 대칭성이 있다 

다대다는 실무에서 쓰면 안된다 

다대일 많이 쓴다 

>> 단방향, 양방향 

- 테이블
- 외래 키 하나로 양쪽 조인 가능
- 사실 방향이라는 개념이 없음
- 객체
- 참조용 필드가 있는 쪽으로만 참조 가능
- 한쪽만 참조하면 단방향
- 양쪽이 서로 참조하면 양방향

사실 양방향이라는 건 없음 

객체 입장에서는 방향이 하나

양방향은 단방향이 2개 있는 것 

>> 연관관계의 주인 

- 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음
- 객체 양방향 관계는 A → B, B → A 처럼 참조가 2군데
- 객체 양방향 관계는 참조가 2군데 있음. 둘 중 테이블의 외래 키를 관리할 곳을 지정해야 함
- 연관관계의 주인 : 외래 키를 관리하는 참조
- 주인의 반대편 : 외래 키에 영향을 주지 않음. 단순 조회만

>> 다대일

다쪽에 외래키가 가야 한다 

>> 다대일 단방향 정리 

- 가장 많이 사용하는 연관관계
- 다대일의 반대는 일대다

앞에 있는 게 연관관계 주인공 

>> 다대일 양방향 정리 

- 외래 키가 있는 쪽이 연관관계의 주인
- 양쪽을 서로 참조하도록 개발

>> 일대다 

>> 일대다 단방향 정리 

- 일대다 단방향은 일대다에서 일이 연관관계의 주인
- 테이블 일대다 관계는 항상 다쪽에 외래 키가 있음 (큰 단점)
- 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조
- @JoinColumn을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함 (중간에 테이블을 하나 추가함)

- 일대다 단방향 매핑의 단점
- 엔티티가 관리하는 외래 키가가 다른 테이블에 있음
- 연관관계 관리를 위해 추가로 UPDATE SQL 실행
- 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자

처음부터 일대다 사용하지 않는 것도 방법 중의 하나 

>> 일대다 양방향 정리 

- 이런 매핑은 공식적으로 존재X
- @JoinColumn(insertable=false, updatable=false)
- 읽기 전용 필드를 사용해서 양방향처럼 사용하는 방법
- 다대일 양방향을 사용하자

>> 일대일 

>> 일대일 관계 

- 일대일 관계는 그 반대도 일대일
- 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
- 주 테이블에 외래 키
- 대상 테이블에 외래 키
- 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가

>> 일대일 : 주 테이블에 외래 키 단방향 

>> 일대일 : 주 테이블에 외래 키 양방향 정리 

- 다대일 양방향 매핑처럼 외래 키가 있는 곳이 연관관계의 주인
- 반대편은 mappedBy 적용

>> 일대일 : 대상 테이블에 외래 키 단방향 

- 단방향 관계는 JPA 지원X
- 양방향 관계는 지원
- 사실 일대일 주 테이블에 외래 키 양방향과 매핑 방법은 같음

집 

- [ ]  설치 끝내기
- [ ]  강의 끝까지 듣기

>> 일대일 정리 

☀️ 주 테이블에 외래 키 

- 주 객체가 대상 객체의 참조를 가지는 것처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
- 객체지향 개발자 선호
- JPA 매핑 편리
- 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
- 단점 : 값이 없으면 외래 키에 null 허용

☀️ 대상 테이블에 외래 키 

- 대상 테이블에 외래 키가 존재
- 전통적인 데이터베이스 개발자 선호
- 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조유지
- 단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨 (프록시는 뒤에서 설명)

pk는 의미없는 값 쓰는 게 좋다. 

>> 내일 코드리뷰할때 실전예제 코드로 하는 게 좋겠어 

>> 실전 예제 3 - 다양한 연관관계 매핑 

>> 배송, 카테고리 추가 - 엔티티 

- 주문과 배송은 1:1 (@OneToMany)
- 상품과 카테고리는 N:M (@ManyToMany)

>> 배송, 카테고리 추가 - ERD 

>> 배송, 카테고리 추가 - 엔티티 상세 

>> N:M 관계는 1:N, N:1로 

- 테이블의 N:M 관계는 중간 테이블을 이용해서 1:N, N:1
- 실전에서는 중간 테이블이 단순하지 않다
- @ManyToMany는 제약: 필드 추가X, 엔티티 테이블 불일치
- 실전에서는 @ManyToMany 사용X